---
tags: project
author: PikaChin
title: AStarEngine
---
AStarEngine
===
This project is developped for the final project of NSD in NYCU.

<!-- Outline:
[TOC] -->

## Introduction
A* Search is a path finding algorithm which is usually used in the game development and some graph problem. The difference of A* Search and Dijkstra is that A* Search introduce the heuristic function. The heuristic function, which gives an intuitive of the current state/node to the goal/target.

The algorithm is as following:
![](https://i.imgur.com/0B2EKC9.png)
At the start node, it can found the adjecent node, then calculate the f(node) value. The f(node) value is determined by g(node) and h(node).
g(node) is same with the Dijkstra distance value. h(node) is the heuristic value determined by the user defined heuristic function, for example, Manhattan Distance.
![](https://i.imgur.com/7Og0iPP.png)
Next, try to pop out the node with lowest f(node) value. Tag it as visited, and do the same process as the above.
![](https://i.imgur.com/YMzA8XV.png)
Keep doing the process until reach the target node.

In this project, the logic of A* search is already written with c++. The user can experience A* search through implementing their own environment in c++/python.

The user should follow the environment interface to implement their own game. I will futher explain the interface of the environment in latter part.

## How to Start
The project is written with C++ and Python. The system architecture will show in latter section. Here, you only need to know that the project is build with C++ and bind the C++ library into Python by using Pybind11.

### Build
I suggest you to build the project with the Container:
```bash
podman run \
    -v=$PWD:/workspace \
    -w=/workspace \
    -it \
    --name="A_Star" \
    derrick4563/nsd:latest

# Then cd into the workspace directory
cd /workspace

# Build the project with setup.sh
./script/setup.sh -build
```

> **Hint**: Use docker to run the container is ok, but I prefer podman. The reason for using podman rather than docker you can refer to [this website](https://www.lambdatest.com/blog/podman-vs-docker/).

The setup script will build the project generating test binary executable and pybind library. The pybind library name is **astar_engine** which will be placed into **src/py_env** directory automatically.

Because the pybind library is inside **src/py_env**, the Python environment file should be placed into this directory.

Try to import astar_engine in Python:
```python
# cd /workspace/src/py_env
# python3
import astar_engine
```

If you want to implement your own environment in C++, you must have generate some new cpp file. Therefore, you will need to rebuild the project.
At this moment, you can use the rebuild script:
```bash
./script/rebuild.sh
```

### Run Example
There are two example environment I implement in the src directory. They are Randome Maze and Sliding Puzzle Game implemented in C++ and Python respectively.

### Run Maze
You can run maze with AStarEngine by execute the compiled binary executable file main
```bash
# Usage: ./main [default|maze|your cpp env]
./build/main maze
```
It will show the random maze, which random generated by DFS, and also the founded path of this generated maze. The path is given by A* engine.

![](https://i.imgur.com/Iz92VcG.png)
![](https://i.imgur.com/1fsPdPg.png)

### Run Sliding Puzzle Game
To run Sliding Puzzle Game, this game is implemented in Python, so you can run the Python file main.py
```bash
# Usage: python3 main.py [sliding_puzzle|your py env]
python3 src/main.py sliding_puzzle
```
Run this game will show the order to slide the board. The first board is about initial board status, which has been random slided.
Because the path will be too long when the board size is large, I show the simple example of this game.

![](https://i.imgur.com/5J2cJLK.png)

## Implement Your Own Environment
When you want to try A* search on different environment, you should implement your own environment.

You can choose C++ or Python to implement your environment or game. Both need to follow the rule I mention below.

> Be careful that if the environment/game is implemented in Python, the speed must be slower than C++. Therefore, if you want to have best A* search speed, you need to implement the environment/game with C++.

### Implement in C++
To implement with C++, you need to create two class: State and Environment.
Your own Environment and State **must** inherit base State and Environment class, just like the maze example I did.

```c++
// Inherit State class
class MazeState : public State {};
// Inherit Environment class
class Maze : public Environment {};
```

State: You should override two methods
* encode method
* decode method
```c++
virtual std::string encode() { return ""; }
virtual void decode(std::string) {}
```
encode will encode the state object and return a unique key which type is string.

decode will analyze the given key, and retrive the information from the key into the state obj.

Environment: Their are some method you can choosed to override
* **state_transition**: Will return the next state key from the given state and the action id. 
* **valid_actions**: Will return a vector of valid actions depend on the given state.
* **astar_heuristic**: This is the environment user specified heuristic function.
* **build_state**: Will create a state object you have defined for your environment/game. The returned state object must be initialize with the given key.
* **to_string** (with two type of overloading): This function is just used to show the information of your environment or game. Take maze for example: show the maze wall on the terminal.

```c++
virtual std::string state_transition(std::shared_ptr<State>, int /* action index */);
virtual std::vector<int> valid_actions(std::shared_ptr<State>);
virtual float astar_heuristic(std::shared_ptr<State>) { return -1.0; }
virtual std::shared_ptr<State> build_state(std::string) { return nullptr; }
virtual std::string to_string() const { return ""; }
virtual std::string to_string(const Path&) const { return ""; }
```

You may override all of them to implement your own environment/game, or you can use append_edge to add the edge into the base environment. This means base Environment already maintain a graph, and the graph's edges are stored in a string-to-string unordered_map.

The method append_edge in the environment is used to apply a new edge into this grpah.
```c++
void append_edge(std::string, std::string);
```
These two parameter are key of a state. That is to say, build an edge of these two state.

> If you want to just use append_edge to apply edge into graph, you **must not override state_transition and valid_actions**. Their default behavior is to retrive the information of the graph.

### Implement in Python
Implement in Python is very similar with C++, and more easily.

The Environment in Python still need to create two type of class:
* State
* Environment

As you will guess, there are some methods you should define in your State and Environment class.

For State, you need to define:
* encode
* decode

These two method has same input and return definition with C++ State. A simple example is the SlidingPuzzleState:
```python
def encode(self):
    key = str(self.board_size_) + '_'
    for i in range(self.board_size_ * self.board_size_):
        key += f'{self.board_[i // self.board_size_][i % self.board_size_]};'
    return key[:-1]

def decode(self, key):
    terms = key.split('_')
    if self.board_size_ == 0:
        self.board_size_ = int(terms[0])
        self.board_ = [[0 for i in range(self.board_size_)] for j in range(self.board_size_)]
    board = terms[1].split(';')
    for i in range(len(board)):
        self.board_[i // self.board_size_][i % self.board_size_] = int(board[i])
        if int(board[i]) == 0:
            self.empty_pos_[0] = i // self.board_size_
            self.empty_pos_[1] = i % self.board_size_
```
encode method return a key according to the state status. decode method retrive status information form a state key. The key is a string.

For Environment, you need to define:
* **state_transition**: The input is a state key and a action id, you should define how to act an action on a state in this method.
* **valid_actions**: This input is a state key, and you just need to return a tuple of valid actions id.
* **astar_heuristic**: The heuristic you can defined by your own. It can be anything what you want.

It's free to define the Environment, **just follow the definition of these methods**. The example game Sliding Puzzle show how to do a sample define for you. You can follow the style of Sliding Puzzle, or you can create one with your own idea.

## System Architecture
